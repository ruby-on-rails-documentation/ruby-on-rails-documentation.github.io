(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{290:function(e,t,a){"use strict";a.r(t);var n=a(13),s=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"action-cable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#action-cable"}},[e._v("#")]),e._v(" Action Cable")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Introduction")]),e._v(" "),t("p",[e._v("In many modern web applications, WebSockets are used to implement realtime, live-updating user interfaces. When some data is updated on the server, a message is typically sent over a WebSocket connection to be handled by the client. WebSockets provide a more efficient alternative to continually polling your application's server for data changes that should be reflected in your UI.")]),e._v(" "),t("p",[e._v("For example, imagine your application is able to export a user's data to a CSV file and email it to them. However, creating this CSV file takes several minutes so you choose to create and mail the CSV within a queued job. When the CSV has been created and mailed to the user, we can use event broadcasting to dispatch event that is received by our application's JavaScript. Once the event is received, we can display a message to the user that their CSV has been emailed to them without them ever needing to refresh the page.")]),e._v(" "),t("p",[e._v('To assist you in building these types of features, Rails makes it easy to "Actioncable" your server-side events over a WebSocket connection. Broadcasting your Rails events allows you to share the same event names and data between your server-side Rails application and your client-side JavaScript application.')]),e._v(" "),t("p",[e._v("The core concepts behind broadcasting are simple: clients connect to named channels on the frontend, while your Rails application broadcasts events to these channels on the backend. These events can contain any additional data you wish to make available to the frontend.")])]),e._v(" "),t("li",[t("p",[e._v("Terminology")]),e._v(" "),t("p",[t("strong",[e._v("Connections")])]),e._v(" "),t("p",[t("em",[e._v("Connections")]),e._v(" form the foundation of the client-server relationship. A single Action Cable server can handle multiple connection instances. It has one connection instance per WebSocket connection. A single user may have multiple WebSockets open to your application if they use multiple browser tabs or devices.")]),e._v(" "),t("p",[t("strong",[e._v("Consumers")])]),e._v(" "),t("p",[e._v("The client of a WebSocket connection is called the "),t("em",[e._v("consumer")]),e._v(". In Action Cable, the consumer is created by the client-side JavaScript framework.")]),e._v(" "),t("p",[t("strong",[e._v("Channels")])]),e._v(" "),t("p",[e._v("Each consumer can, in turn, subscribe to multiple "),t("em",[e._v("channels")]),e._v(". Each channel encapsulates a logical unit of work, similar to what a controller does in a typical MVC setup. For example, you could have a "),t("code",[e._v("ChatChannel")]),e._v(" and an "),t("code",[e._v("AppearancesChannel")]),e._v(", and a consumer could be subscribed to either or both of these channels. At the very least, a consumer should be subscribed to one channel.")]),e._v(" "),t("p",[t("strong",[e._v("Subscribers")])]),e._v(" "),t("p",[e._v("When the consumer is subscribed to a channel, they act as a "),t("em",[e._v("subscriber")]),e._v(". The connection between the subscriber and the channel is, surprise-surprise, called a subscription. A consumer can act as a subscriber to a given channel any number of times. For example, a consumer could subscribe to multiple chat rooms at the same time. (And remember that a physical user may have multiple consumers, one per tab/device open to your connection).")]),e._v(" "),t("p",[t("strong",[e._v("Pub/Sub")])]),e._v(" "),t("p",[t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern",target:"_blank",rel:"noopener noreferrer"}},[e._v("Pub/Sub"),t("OutboundLink")],1),e._v(" or Publish-Subscribe refers to a message queue paradigm whereby senders of information (publishers), send data to an abstract class of recipients (subscribers), without specifying individual recipients. Action Cable uses this approach to communicate between the server and many clients.")]),e._v(" "),t("p",[t("strong",[e._v("Broadcastings")])]),e._v(" "),t("p",[e._v("A broadcasting is a pub/sub link where anything transmitted by the broadcaster is sent directly to the channel subscribers who are streaming that named broadcasting. Each channel can be streaming zero or more broadcastings.")])]),e._v(" "),t("li")])])}),[],!1,null,null,null);t.default=s.exports}}]);